<!DOCTYPE html>
<html class="staticrypt-html">

<head>
    <meta charset="utf-8" />
    <title>Parto Pawiro Family Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
    <meta http-equiv="pragma" content="no-cache" />

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #ffffff;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            color: #ffffff;
            background: #0000001e;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"],
        input[type="text"] {
            background: inherit;
            border: 0;
            box-sizing: border-box;
            /* This ensures padding is included in the total width */
            font-size: 14px;
            outline: 0;
            padding: 15px 30px 15px 15px;
            /* Adjust the padding to ensure there is space for the icon */
            width: 100%;
        }

        .staticrypt-password-container {
            position: relative;
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            box-sizing: border-box;
        }

        .staticrypt-toggle-password-visibility {
            cursor: pointer;
            height: 20px;
            opacity: 60%;
            padding: 13px;
            position: absolute;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 20px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #1e1e1e;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #ffffff;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover,
        .staticrypt-form .staticrypt-decrypt-button:active,
        .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #1e1e1e;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #1e1e1e;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type="checkbox"] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border 0.75s linear infinite;
            animation: spinner-border 0.75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }

        :root {
            --toast-bg-success: #4caf50;
            --toast-bg-error: #f44336;
            --toast-bg-info: #2196f3;
            --toast-bg-warning: #ff9800;
        }

        .toast-container {
            position: fixed;
            z-index: 9999;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .top-right {
            top: 20px;
            right: 20px;
            align-items: flex-end;
        }

        .top-left {
            top: 20px;
            left: 20px;
            align-items: flex-start;
        }

        .bottom-right {
            bottom: 20px;
            right: 20px;
            align-items: flex-end;
        }

        .bottom-left {
            bottom: 20px;
            left: 20px;
            align-items: flex-start;
        }

        .top-center {
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            align-items: center;
        }

        .toast {
            position: relative;
            color: #fff;
            padding: 16px 20px;
            border-radius: 8px;
            min-width: 280px;
            max-width: 350px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            overflow: hidden;
            display: flex;
            align-items: flex-start;
            gap: 10px;
            animation: slideIn 0.3s ease;
        }

        .toast-icon {
            font-size: 20px;
            margin-top: 2px;
        }

        .toast-message {
            flex: 1;
        }

        .toast-close {
            position: absolute;
            top: 10px;
            right: 12px;
            background: none;
            border: none;
            color: white;
            font-size: 18px;
            cursor: pointer;
        }

        .toast-progress {
            position: absolute;
            bottom: 0;
            left: 0;
            height: 4px;
            background: rgba(255, 255, 255, 0.7);
            width: 100%;
            transition: width linear;
        }

        .toast.success {
            background-color: var(--toast-bg-success);
        }

        .toast.error {
            background-color: var(--toast-bg-error);
        }

        .toast.info {
            background-color: var(--toast-bg-info);
        }

        .toast.warning {
            background-color: var(--toast-bg-warning);
        }

        @keyframes slideIn {
            from {
                transform: translateY(-20px);
                opacity: 0;
            }

            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
    </style>
</head>

<body class="staticrypt-body">
    <div class="toastify">

    </div>

    <div id="staticrypt_loading" class="staticrypt-spinner-container">
        <div class="staticrypt-spinner"></div>
    </div>

    <div id="staticrypt_content" class="staticrypt-content hidden">
        <div class="staticrypt-page">
            <div class="staticrypt-form">
                <div class="staticrypt-instructions">
                    <p class="staticrypt-title">Parto Pawiro Family</p>
                    <p>Masukan Password Untuk Akses</p>
                </div>

                <hr class="staticrypt-hr" />

                <form id="staticrypt-form" action="#" method="post">
                    <div class="staticrypt-password-container">
                        <input id="staticrypt-password" type="password" name="password" placeholder="Password"
                            autofocus />

                        <img class="staticrypt-toggle-password-visibility" alt="Show password" title="Show password"
                            src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==" />
                    </div>

                    <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                        <input id="staticrypt-remember" type="checkbox" name="remember" />
                        Selalu Ingat
                    </label>

                    <input type="submit" class="staticrypt-decrypt-button" value="MASUK" />
                </form>
            </div>
        </div>
    </div>

    <script>
        // these variables will be filled when generating the file - the template format is 'variable_name'
        const staticryptInitiator = ((function () {
            const exports = {};
            const cryptoEngine = ((function () {
                const exports = {};
                const { subtle } = crypto;

                const IV_BITS = 16 * 8;
                const HEX_BITS = 4;
                const ENCRYPTION_ALGO = "AES-CBC";

                /**
                 * Translates between utf8 encoded hexadecimal strings
                 * and Uint8Array bytes.
                 */
                const HexEncoder = {
                    /**
                     * hex string -> bytes
                     * @param {string} hexString
                     * @returns {Uint8Array}
                     */
                    parse: function (hexString) {
                        if (hexString.length % 2 !== 0) throw "Invalid hexString";
                        const arrayBuffer = new Uint8Array(hexString.length / 2);

                        for (let i = 0; i < hexString.length; i += 2) {
                            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
                            if (isNaN(byteValue)) {
                                throw "Invalid hexString";
                            }
                            arrayBuffer[i / 2] = byteValue;
                        }
                        return arrayBuffer;
                    },

                    /**
                     * bytes -> hex string
                     * @param {Uint8Array} bytes
                     * @returns {string}
                     */
                    stringify: function (bytes) {
                        const hexBytes = [];

                        for (let i = 0; i < bytes.length; ++i) {
                            let byteString = bytes[i].toString(16);
                            if (byteString.length < 2) {
                                byteString = "0" + byteString;
                            }
                            hexBytes.push(byteString);
                        }
                        return hexBytes.join("");
                    },
                };

                /**
                 * Translates between utf8 strings and Uint8Array bytes.
                 */
                const UTF8Encoder = {
                    parse: function (str) {
                        return new TextEncoder().encode(str);
                    },

                    stringify: function (bytes) {
                        return new TextDecoder().decode(bytes);
                    },
                };

                /**
                 * Salt and encrypt a msg with a password.
                 */
                async function encrypt(msg, hashedPassword) {
                    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
                    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
                    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

                    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

                    const encrypted = await subtle.encrypt(
                        {
                            name: ENCRYPTION_ALGO,
                            iv: iv,
                        },
                        key,
                        UTF8Encoder.parse(msg)
                    );

                    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
                    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
                }
                exports.encrypt = encrypt;

                /**
                 * Decrypt a salted msg using a password.
                 *
                 * @param {string} encryptedMsg
                 * @param {string} hashedPassword
                 * @returns {Promise<string>}
                 */
                async function decrypt(encryptedMsg, hashedPassword) {
                    const ivLength = IV_BITS / HEX_BITS;
                    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
                    const encrypted = encryptedMsg.substring(ivLength);

                    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

                    const outBuffer = await subtle.decrypt(
                        {
                            name: ENCRYPTION_ALGO,
                            iv: iv,
                        },
                        key,
                        HexEncoder.parse(encrypted)
                    );

                    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
                }
                exports.decrypt = decrypt;

                /**
                 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
                 *
                 * @param {string} password
                 * @param {string} salt
                 * @returns {Promise<string>}
                 */
                async function hashPassword(password, salt) {
                    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
                    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
                    let hashedPassword = await hashLegacyRound(password, salt);

                    hashedPassword = await hashSecondRound(hashedPassword, salt);

                    return hashThirdRound(hashedPassword, salt);
                }
                exports.hashPassword = hashPassword;

                /**
                 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
                 * compatibility.
                 *
                 * @param {string} password
                 * @param {string} salt
                 * @returns {Promise<string>}
                 */
                function hashLegacyRound(password, salt) {
                    return pbkdf2(password, salt, 1000, "SHA-1");
                }
                exports.hashLegacyRound = hashLegacyRound;

                /**
                 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
                 * remember-me/autodecrypt links, we need to support going from that to more iterations.
                 *
                 * @param hashedPassword
                 * @param salt
                 * @returns {Promise<string>}
                 */
                function hashSecondRound(hashedPassword, salt) {
                    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
                }
                exports.hashSecondRound = hashSecondRound;

                /**
                 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
                 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
                 *
                 * @param hashedPassword
                 * @param salt
                 * @returns {Promise<string>}
                 */
                function hashThirdRound(hashedPassword, salt) {
                    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
                }
                exports.hashThirdRound = hashThirdRound;

                /**
                 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
                 *
                 * @param {string} password
                 * @param {string} salt
                 * @param {int} iterations
                 * @param {string} hashAlgorithm
                 * @returns {Promise<string>}
                 */
                async function pbkdf2(password, salt, iterations, hashAlgorithm) {
                    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

                    const keyBytes = await subtle.deriveBits(
                        {
                            name: "PBKDF2",
                            hash: hashAlgorithm,
                            iterations,
                            salt: UTF8Encoder.parse(salt),
                        },
                        key,
                        256
                    );

                    return HexEncoder.stringify(new Uint8Array(keyBytes));
                }

                function generateRandomSalt() {
                    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

                    return HexEncoder.stringify(new Uint8Array(bytes));
                }
                exports.generateRandomSalt = generateRandomSalt;

                async function signMessage(hashedPassword, message) {
                    const key = await subtle.importKey(
                        "raw",
                        HexEncoder.parse(hashedPassword),
                        {
                            name: "HMAC",
                            hash: "SHA-256",
                        },
                        false,
                        ["sign"]
                    );
                    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

                    return HexEncoder.stringify(new Uint8Array(signature));
                }
                exports.signMessage = signMessage;

                function getRandomAlphanum() {
                    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

                    let byteArray;
                    let parsedInt;

                    // Keep generating new random bytes until we get a value that falls
                    // within a range that can be evenly divided by possibleCharacters.length
                    do {
                        byteArray = crypto.getRandomValues(new Uint8Array(1));
                        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
                        parsedInt = byteArray[0] & 0xff;
                    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

                    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
                    const randomIndex = parsedInt % possibleCharacters.length;

                    return possibleCharacters[randomIndex];
                }

                /**
                 * Generate a random string of a given length.
                 *
                 * @param {int} length
                 * @returns {string}
                 */
                function generateRandomString(length) {
                    let randomString = "";

                    for (let i = 0; i < length; i++) {
                        randomString += getRandomAlphanum();
                    }

                    return randomString;
                }
                exports.generateRandomString = generateRandomString;

                return exports;
            })());
            const codec = ((function () {
                const exports = {};
                /**
               * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
               *
               * @param cryptoEngine - the engine to use for encryption / decryption
               */
                function init(cryptoEngine) {
                    const exports = {};

                    /**
                     * Top-level function for encoding a message.
                     * Includes password hashing, encryption, and signing.
                     *
                     * @param {string} msg
                     * @param {string} password
                     * @param {string} salt
                     *
                     * @returns {string} The encoded text
                     */
                    async function encode(msg, password, salt) {
                        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

                        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

                        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
                        // it in localStorage safely, we don't use the clear text password)
                        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

                        return hmac + encrypted;
                    }
                    exports.encode = encode;

                    /**
                     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
                     * we don't need to hash the password multiple times.
                     *
                     * @param {string} msg
                     * @param {string} hashedPassword
                     *
                     * @returns {string} The encoded text
                     */
                    async function encodeWithHashedPassword(msg, hashedPassword) {
                        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

                        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
                        // it in localStorage safely, we don't use the clear text password)
                        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

                        return hmac + encrypted;
                    }
                    exports.encodeWithHashedPassword = encodeWithHashedPassword;

                    /**
                     * Top-level function for decoding a message.
                     * Includes signature check and decryption.
                     *
                     * @param {string} signedMsg
                     * @param {string} hashedPassword
                     * @param {string} salt
                     * @param {int} backwardCompatibleAttempt
                     * @param {string} originalPassword
                     *
                     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
                     */
                    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
                        const encryptedHMAC = signedMsg.substring(0, 64);
                        const encryptedMsg = signedMsg.substring(64);
                        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

                        if (decryptedHMAC !== encryptedHMAC) {
                            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
                            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
                            originalPassword = originalPassword || hashedPassword;
                            if (backwardCompatibleAttempt === 0) {
                                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
                            }
                            if (backwardCompatibleAttempt === 1) {
                                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
                            }

                            return { success: false, message: "Signature mismatch" };
                        }

                        return {
                            success: true,
                            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
                        };
                    }
                    exports.decode = decode;

                    return exports;
                }
                exports.init = init;

                return exports;
            })());
            const decode = codec.init(cryptoEngine).decode;

            /**
             * Initialize the staticrypt module, that exposes functions callbable by the password_template.
             *
             * @param {{
             *  staticryptEncryptedMsgUniqueVariableName: string,
             *  isRememberEnabled: boolean,
             *  rememberDurationInDays: number,
             *  staticryptSaltUniqueVariableName: string,
             * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
             *
             * @param {{
             *  rememberExpirationKey: string,
             *  rememberPassphraseKey: string,
             *  replaceHtmlCallback: function,
             *  clearLocalStorageCallback: function,
             * }} templateConfig - object of data that can be configured by a custom password_template.
             */
            function init(staticryptConfig, templateConfig) {
                const exports = {};

                /**
                 * Decrypt our encrypted page, replace the whole HTML.
                 *
                 * @param {string} hashedPassword
                 * @returns {Promise<boolean>}
                 */
                async function decryptAndReplaceHtml(hashedPassword) {
                    const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
                    const { replaceHtmlCallback } = templateConfig;

                    const result = await decode(
                        staticryptEncryptedMsgUniqueVariableName,
                        hashedPassword,
                        staticryptSaltUniqueVariableName
                    );
                    if (!result.success) {
                        return false;
                    }
                    const plainHTML = result.decoded;

                    // if the user configured a callback call it, otherwise just replace the whole HTML
                    if (typeof replaceHtmlCallback === "function") {
                        replaceHtmlCallback(plainHTML);
                    } else {
                        document.write(plainHTML);
                        document.close();
                    }

                    return true;
                }

                /**
                 * Attempt to decrypt the page and replace the whole HTML.
                 *
                 * @param {string} password
                 * @param {boolean} isRememberChecked
                 *
                 * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
                 *   expose more information in the future we can do it without breaking the password_template
                 */
                async function handleDecryptionOfPage(password, isRememberChecked) {
                    const { staticryptSaltUniqueVariableName } = staticryptConfig;

                    // decrypt and replace the whole page
                    const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
                    return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
                }
                exports.handleDecryptionOfPage = handleDecryptionOfPage;

                async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
                    const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
                    const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

                    const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

                    if (!isDecryptionSuccessful) {
                        return {
                            isSuccessful: false,
                            hashedPassword,
                        };
                    }

                    // remember the hashedPassword and set its expiration if necessary
                    if (isRememberEnabled && isRememberChecked) {
                        window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

                        // set the expiration if the duration isn't 0 (meaning no expiration)
                        if (rememberDurationInDays > 0) {
                            window.localStorage.setItem(
                                rememberExpirationKey,
                                (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                            );
                        }
                    }

                    return {
                        isSuccessful: true,
                        hashedPassword,
                    };
                }
                exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

                /**
                 * Clear localstorage from staticrypt related values
                 */
                function clearLocalStorage() {
                    const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

                    if (typeof clearLocalStorageCallback === "function") {
                        clearLocalStorageCallback();
                    } else {
                        localStorage.removeItem(rememberPassphraseKey);
                        localStorage.removeItem(rememberExpirationKey);
                    }
                }

                async function handleDecryptOnLoad() {
                    let isSuccessful = await decryptOnLoadFromUrl();

                    if (!isSuccessful) {
                        isSuccessful = await decryptOnLoadFromRememberMe();
                    }

                    return { isSuccessful };
                }
                exports.handleDecryptOnLoad = handleDecryptOnLoad;

                /**
                 * Clear storage if we are logging out
                 *
                 * @returns {boolean} - whether we logged out
                 */
                function logoutIfNeeded() {
                    const logoutKey = "staticrypt_logout";

                    // handle logout through query param
                    const queryParams = new URLSearchParams(window.location.search);
                    if (queryParams.has(logoutKey)) {
                        clearLocalStorage();
                        return true;
                    }

                    // handle logout through URL fragment
                    const hash = window.location.hash.substring(1);
                    if (hash.includes(logoutKey)) {
                        clearLocalStorage();
                        return true;
                    }

                    return false;
                }

                /**
                 * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
                 * try to do it if needed.
                 *
                 * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
                 */
                async function decryptOnLoadFromRememberMe() {
                    const { rememberDurationInDays } = staticryptConfig;
                    const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

                    // if we are login out, terminate
                    if (logoutIfNeeded()) {
                        return false;
                    }

                    // if there is expiration configured, check if we're not beyond the expiration
                    if (rememberDurationInDays && rememberDurationInDays > 0) {
                        const expiration = localStorage.getItem(rememberExpirationKey),
                            isExpired = expiration && new Date().getTime() > parseInt(expiration);

                        if (isExpired) {
                            clearLocalStorage();
                            return false;
                        }
                    }

                    const hashedPassword = localStorage.getItem(rememberPassphraseKey);

                    if (hashedPassword) {
                        // try to decrypt
                        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

                        // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
                        // the user fill the password form again
                        if (!isDecryptionSuccessful) {
                            clearLocalStorage();
                            return false;
                        }

                        return true;
                    }

                    return false;
                }

                async function decryptOnLoadFromUrl() {
                    const passwordKey = "staticrypt_pwd";
                    const rememberMeKey = "remember_me";

                    // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
                    // since it sends the hashed password to the server which isn't needed)
                    const queryParams = new URLSearchParams(window.location.search);
                    const hashedPasswordQuery = queryParams.get(passwordKey);
                    const rememberMeQuery = queryParams.get(rememberMeKey);

                    const urlFragment = window.location.hash.substring(1);
                    // get the password from the url fragment
                    const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
                    const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
                    const rememberMeFragment = urlFragment.includes(rememberMeKey);

                    const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
                    const rememberMe = rememberMeFragment || rememberMeQuery;

                    if (hashedPassword) {
                        return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
                    }

                    return false;
                }

                return exports;
            }
            exports.init = init;

            return exports;
        })());
        const templateError = "Pasword Salah...!!!",
            templateToggleAltShow = "Perlihatkan Password",
            templateToggleAltHide = "Sembunyikan Password",
            isRememberEnabled = true,
            staticryptConfig = { "staticryptEncryptedMsgUniqueVariableName": "5efd348766c5085b5a243c545220aea72f4dd4de98e51aa08fc4f01f19df815598755b58de3c0d7b3857ced323805cb396eddfda3af6d87d30b553d923615a4b5fd3e49aba2cc54b788b98f50364c65ed96410bd7f410dadc8ec125e62d361376087f0744906037b725cf585a3e427f3daa27aad8cd14eed6c3d6f6c5efb01925ea9761aac68f41e11e180fc038eff24c7f6a237429907d5967324e0295ea7c04c953209ff15d68a76414707489239434b1594a8588e4fe4fadf37dca6ea6fc44e78750c9241e69af287af663cad834b770755e78260519b0fe20d8cfbd3d7c1117ae318be5dbfa8ab3a37c37b04f48d8dff304b4ccee716fcedf373c8c1aa68a69f85110448db8c085df08cabc3c36f427b7133ad3c37fa4e7957cfbfc8996d46d13d228e6c2cf47c6855a177f0ae14ca95990d47687aa3b5907c3ef4081a67f9855f3e738e42e81f90677e368ca087b5d0240ce77096cff31a12028a409ffe6d1a8bbeea1ca66733eda537308e6aeb1ee624d49962454ac323d4e3407cb2722f8d1d80faa694bc62a6b9fadc69ef588a9d6f0289589ec287c3231311d5170e3226b17c8548ca7ecfdd921a73b7a49679aa20ce915bc1db39686268185f5855f9abfba89872c38d74f82c7d45b85186e05d7ee6803f4b769a4cfbd98051edf17379490cb85cd91b79fbe4b6d61076436ada7165a8a4e3b99184c18b68346df881ab57f2fa49ad8bb64c9162e514bbb0dc8ee86575cc19c422c0640a1bcc598af509e3c13900600d0e64ec3a377c67588fd5f811edc4048c0b737d01d40726e2000661c6ee457dd602a3899590f2161e563a13ac5516ed809765cc3b11b933be12e03240274c9c2e8f74003ceafb8d17830bf768aaf12152753e010afc232522c947a246938db5fee2326abaa6e616923a6867a1587ff0511d67aafcd5478cccd5d1d7b31b9af091a034b48065a01e9fc0951196bc50a520b8c4fe4f92a9e6839db9e0a031b41f150e34ed8a97d407aada2d44bdebba16beecc57ebdfe3e116b5cdb2a4d22862e4cefc72dd98d379342d32f4d7969412565bd9b3208b03953f105c9582ce0433df2d0bab0609924bea36a7f0bdffdbd136d61a5a8f2407bdf288b83b927afd6906fb3c683672631050397ccbd24c3e1d9b2fb56b6c001b015096d53ff081d1f74e5e0a96461d184cb38e5d1228ad71e0dde3fa4d3c1b08c94436e93b885e550219ba7552b71ce5d276476756c018a5681e3957b8b042c03def479b9d797cecb5e2f85219efa968b8e8be4d18b76c86a4ed6fa1a2d9658fdf6ef28154c29dfa4167f61d13cb9ec24edcd86af27aa79e0c31ea28104d3b21c85c29098ae82f7c97595133c4fd36f89fa64cecde947b1a25de9ac5197245f8895d220e3ea44f3a48f4ec40ab1253091e198d0009fcf004c214c5526465336a62841dbfe0dc2db1dbedf46e2a13b102189a7f49e941a96471e03536a7ce0a1addb962909363e58d99cde7293bb60c34c6ad557ee3292cd2d9e2780eb1aa2327df3e35458cb4e1e2cda01c53381076b45d6f205b2ace3e880d893c41ddded11f82df6381115de05d546302cf11b5357cf6f2977c60773b96c01a2d8706139f33323be16774bd33d5cbf8dd31a4124b64f9b81e8b3dc2236e0fae103bc2f207c2d3a533d2ab3bd965908b0ab751f26507feb0ef5581a7bf135bdb8440d176e2a4d62ddb53f662bc8e1c22c77d58b8f669a86522d5a73d7145747cd19b2541cd119a2e88d40881c5a07b4159961d9fd22db75bea484fc54f40345c92e9a407ce00d5560c98754ac6b4bdb0c2752cf6906d3f5a0069032b5fe5dfd72f7f1bdbaf6723d665e0489bb7167251c89b0f0783a0daa9b0d6cb79170d91518700abd01f1ac3c4d31a0ba5f9abf75106871762f17f5cfc6bd686618e8d1590cdc847c964195de3cab54d56aa1359383a3932bf9724b1ef71b679194f006f6f35a2b90605245a5078e9ac4473358dcc1cc1b4eb18edc1a9563ed381739a7b7ba8239112db4bb89c5fd02986ccbe21441c034f2355cd8efd153da699691b5fbb26e35d481c277203ca5560401bf39c22fa9518013fa30f8db5b1488699bbc0807cf96c0cc65d97fb2c66244d4baf0e98513da0eeafa8595f557dee73c0f620d8008d93a650dabe4e50b772f29217aa10605844b6d121af9b2d2384ab890fda18910d5642a8fa6fba77f53a5c80591af352db88fe6614c7ad4e42069df487fb9683a6ee9fda0338ca080d9b69d81b9416d795c871734c061c670c62812c374602f5ad33a59c7bb98a6f01cf285f0b82dad930e666ea91f9003e096e0ead0eb42a3fd841d878c4ab32b5de5864751d6ef687ed6b099619f1490e89efc21733765aa1664c1b982bbfe2d", "isRememberEnabled": true, "rememberDurationInDays": 0, "staticryptSaltUniqueVariableName": "b93bbaf35459951c47721d1f3eaeb5b9" };

        // you can edit these values to customize some of the behavior of StatiCrypt
        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        // init the staticrypt engine
        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        // try to automatically decrypt on load if there is a saved password
        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

            // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
            // replaced, no need to do anything
            if (!isSuccessful) {
                // hide loading screen
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();

                // show the remember me checkbox
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // toggle password visibility
        const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
        // these two icons are coming from FontAwesome
        const imgSrcEyeClosed =
            "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
        const imgSrcEyeOpened =
            "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
        toggleIcon.addEventListener("click", function () {
            const passwordInput = document.getElementById("staticrypt-password");
            if (passwordInput.type === "password") {
                passwordInput.type = "text";
                toggleIcon.src = imgSrcEyeOpened;
                toggleIcon.alt = templateToggleAltHide;
                toggleIcon.title = templateToggleAltHide;
            } else {
                passwordInput.type = "password";
                toggleIcon.src = imgSrcEyeClosed;
                toggleIcon.alt = templateToggleAltShow;
                toggleIcon.title = templateToggleAltShow;
            }
        });

        // Toast
        const Toast = (() => {
            const icons = {
                success: "✅",
                error: "❌",
                info: "ℹ️",
                warning: "⚠️"
            };

            const containerMap = {};

            function getContainer(position) {
                if (!containerMap[position]) {
                    const container = document.createElement("div");
                    container.className = `toast-container ${position}`;
                    document.body.appendChild(container);
                    containerMap[position] = container;
                }
                return containerMap[position];
            }

            function show({ message, type = "info", duration = 3000, position = "top-right" }) {
                const container = getContainer(position);

                const toast = document.createElement("div");
                toast.className = `toast ${type}`;

                const progress = document.createElement("div");
                progress.className = "toast-progress";

                toast.innerHTML = `
          <div class="toast-icon">${icons[type]}</div>
          <div class="toast-message">${message}</div>
          <button class="toast-close">×</button>
        `;
                toast.appendChild(progress);

                container.appendChild(toast);

                const closeBtn = toast.querySelector(".toast-close");
                closeBtn.addEventListener("click", () => {
                    clearTimeout(timer);
                    toast.remove();
                });

                let startTime = Date.now();
                let paused = false;
                let remaining = duration;
                let timer = setTimeout(() => toast.remove(), duration);

                const animateProgress = () => {
                    progress.style.transition = `width ${remaining}ms linear`;
                    progress.style.width = "0%";
                };

                toast.addEventListener("mouseenter", () => {
                    if (!paused) {
                        paused = true;
                        clearTimeout(timer);
                        remaining -= Date.now() - startTime;
                        progress.style.transition = "none";
                    }
                });

                toast.addEventListener("mouseleave", () => {
                    if (paused) {
                        paused = false;
                        startTime = Date.now();
                        timer = setTimeout(() => toast.remove(), remaining);
                        animateProgress();
                    }
                });

                animateProgress();
            }

            return { show };
        })();
        // handle password form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();

            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;

            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

            if (!isSuccessful) {
                Toast.show({ message: templateError, type: 'error', position: 'top-center' });
            }
        });
    </script>
</body>

</html>
